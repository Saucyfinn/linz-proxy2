<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>NZ Property AR — LINZ Property Boundaries (122657)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- A-Frame + AR.js (GPS) -->
  <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
  <script src="https://raw.githack.com/jeromeetienne/ar.js/3.3.2/aframe/build/aframe-ar.min.js"></script>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:transparent;font-family:system-ui,-apple-system,Segoe UI,Roboto}
    .ui{position:fixed;left:10px;right:10px;top:10px;z-index:10;display:flex;gap:.5rem}
    .ui input{flex:1;padding:.6rem .8rem;border:1px solid #bbb;border-radius:.6rem}
    .ui button{padding:.6rem 1rem;border:0;border-radius:.6rem;background:#111;color:#fff}
    .hint{position:fixed;left:0;right:0;bottom:0;padding:.6rem 1rem;background:rgba(0,0,0,.55);color:#fff;text-align:center}
  </style>
</head>
<body>
  <!-- Search UI -->
  <div class="ui">
    <input id="addr" placeholder="Search NZ address (e.g., 1 Queen Street, Auckland)" />
    <button id="btnSearch">Search</button>
    <button id="btnClear" style="background:#666">Clear</button>
  </div>

  <!-- AR scene (GPS) -->
  <a-scene
    renderer="alpha: true; antialias: true"
    vr-mode-ui="enabled: false"
    embedded
    arjs="sourceType: webcam; videoTexture: true; gpsMinAccuracy: 50; gpsTimeInterval: 1000"
  >
    <a-camera id="cam" gps-camera rotation-reader></a-camera>
    <a-entity id="root"></a-entity>
  </a-scene>

  <div class="hint">Open via HTTPS • Allow Camera & Location • Move slowly to initialize</div>

  <script>
    // ===== CONFIG =====
    const LDS_KEY = "YOUR_LDS_KEY_HERE";        // <-- put your LINZ LDS key here
    const PARCEL_LAYER = "layer-122657";        // NZ Property Boundaries (LINZ dataset you linked)

    // Outline style
    const EDGE_COLOR = "#ffd60a";
    const DOT_RADIUS = 0.06;   // ~12 cm
    const DOT_LIFT   = 0.12;   // lift dots a bit off the ground
    const DENSITY_M  = 2.5;    // ~1 dot every 2.5 m

    // UI
    document.getElementById('btnSearch').addEventListener('click', searchAndDraw);
    document.getElementById('btnClear').addEventListener('click', () => {
      document.querySelectorAll('[data-parcel],[data-geocode]').forEach(el => el.remove());
    });

    // Haversine distance (m)
    function distM(lon1, lat1, lon2, lat2) {
      const R = 6371000, toRad = d => d * Math.PI/180;
      const dLat = toRad(lat2-lat1), dLon = toRad(lon2-lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.sqrt(a));
    }

    // Downsample ring of [lon,lat] → dotted outline
    function addOutlineFromRing(root, ringLonLat) {
      if (!ringLonLat || ringLonLat.length < 2) return;
      const pts = ringLonLat.slice();
      const first = pts[0], last = pts[pts.length-1];
      if (first[0] !== last[0] || first[1] !== last[1]) pts.push(first); // close

      for (let i=1; i<pts.length; i++){
        const a = pts[i-1], b = pts[i];
        const segLen = distM(a[0], a[1], b[0], b[1]);
        const steps = Math.max(1, Math.floor(segLen / DENSITY_M));
        for (let s=0; s<steps; s++){
          const t = s/steps;
          const lon = a[0] + (b[0]-a[0]) * t;
          const lat = a[1] + (b[1]-a[1]) * t;
          const dot = document.createElement('a-sphere');
          dot.setAttribute('gps-entity-place', `latitude: ${lat}; longitude: ${lon};`);
          dot.setAttribute('radius', String(DOT_RADIUS));
          dot.setAttribute('color', EDGE_COLOR);
          dot.setAttribute('position', `0 ${DOT_LIFT} 0`);
          dot.setAttribute('data-parcel','1');
          root.appendChild(dot);
        }
      }
    }

    function clearOld() {
      document.querySelectorAll('[data-parcel],[data-geocode]').forEach(el => el.remove());
    }

    // LINZ Geosearch (ArcGIS) → lon/lat
    async function geocodeNZ(address) {
      const url = 'https://services.arcgisonline.co.nz/arcgis/rest/services/LINZ/geosearch/GeocodeServer/findAddressCandidates'
                + '?f=json&outFields=*&outSR=4326&SingleLine=' + encodeURIComponent(address);
      const res = await fetch(url);
      if (!res.ok) throw new Error("Geocode failed: " + res.status);
      const json = await res.json();
      const c = (json.candidates || [])[0];
      if (!c) throw new Error("No address match.");
      return { lon: c.location.x, lat: c.location.y, address: c.address };
    }

    // LINZ WFS: query Property Boundaries (122657) using small bbox around point
    async function fetchParcelAt(lon, lat) {
      for (const d of [0.0003, 0.0006, 0.0012]) { // ~30m, 60m, 120m
        const bbox = `${lon-d},${lat-d},${lon+d},${lat+d},EPSG:4326`;
        const url = `https://data.linz.govt.nz/services;key=${encodeURIComponent(LDS_KEY)}/wfs`
          + `?service=WFS&version=2.0.0&request=GetFeature&typeNames=${encodeURIComponent(PARCEL_LAYER)}`
          + `&outputFormat=application/json&count=1&bbox=${bbox}`;
        const res = await fetch(url);
        if (!res.ok) continue;
        const gj = await res.json();
        if (gj.features && gj.features.length > 0) return gj.features[0];
      }
      throw new Error("No boundary found near that point.");
    }

    // Draw Polygon/MultiPolygon outline
    function drawGeoJSONPolygon(feature) {
      const geom = feature.geometry;
      if (!geom) throw new Error("No geometry in boundary feature.");
      const root = document.getElementById('root');
      if (geom.type === "Polygon") {
        geom.coordinates.forEach(r => addOutlineFromRing(root, r));
      } else if (geom.type === "MultiPolygon") {
        geom.coordinates.forEach(poly => poly.forEach(r => addOutlineFromRing(root, r)));
      } else {
        throw new Error("Unsupported geometry type: " + geom.type);
      }
    }

    // search → geocode → WFS → draw
    async function searchAndDraw() {
      const q = document.getElementById('addr').value.trim();
      if (!q) return;
      try {
        clearOld();
        const pt = await geocodeNZ(q);
        const feature = await fetchParcelAt(pt.lon, pt.lat);
        drawGeoJSONPolygon(feature);

        // magenta marker at geocoded point
        const root = document.getElementById('root');
        const pin = document.createElement('a-box');
        pin.setAttribute('gps-entity-place', `latitude: ${pt.lat}; longitude: ${pt.lon};`);
        pin.setAttribute('color', '#ff2d55');
        pin.setAttribute('scale', '0.5 0.5 0.5');
        pin.setAttribute('position', '0 0.25 0');
        pin.setAttribute('data-geocode','1');
        root.appendChild(pin);
      } catch (e) {
        console.error(e);
        alert(e.message || "Search or boundary fetch failed.");
      }
    }
  </script>
</body>
</html>
